---
title: 회고록 2
description: >-
  프로그래밍에 대한 회고록
author: jay
date: 2025-06-15 20:55:00 +0800
categories: [Retrospect, Geeson]
tags: [retrospect, golang, geeson]
pin: false
media_subpath: ''
---

## golang의 리시버에 관하여

geeson 프로젝의 인증 서버를 go의 gin 라이브러리를 사용해서 구현하다 보니 인터페이스를 구현하고 그를 구현하는 과정에 리시버의 사용에 대해서 혼동이 왔다.

그에 관한 회고 셉션이다.

### 1. 리시버의 구현과 동작 원리

어떤 코드 한줄에 꽂혀서 생각을 하게 되었다. 바로 아래의 코드이다.
``` go
var _ repository.UserRepository = (*UserRepository)(nil)
```
자바에서는 위의 코드는 이상하게 느껴진다. repository.UserRepository는 값타입이고 *UserRepositorty는 포인터 타입이다. 그럼 값타입에 포인터를 넣는다고? 이러한 의문이 드는 것이다.
이 의문에는 두가지 무지가 담겨져 있었다.
1. Go의 특징 중 하나는 untyped nil 상수를 모든 포인터 타입(뿐만 아니라 map, slice, chan, func, interface 타입 등)으로 변환할 수 있다는 점
   - var a2 MyInterface = &b1 이런식의 구현도 가능한 것이다.(물론 아래와 같은 제약사항이 있다.)
3. 리시버에서 해당 변수를 사용할때는 구조체 멤버를 대상의 얕은 복사가 이루어지지만 초기화시에는 주소값 대상의 얕은 복사가 이루어진다.(즉 같은 메모리를 가리킨다.)


```go
type MyInterface interface {
    Foo()
}

// 값 리시버로 구현한 경우
type Impl1 struct{}
func (Impl1) Foo() { fmt.Println("Impl1") }

// 포인터 리시버로 구현한 경우
type Impl2 struct{}
func (*Impl2) Foo() { fmt.Println("Impl2") }

func main() {
    // 1) 값 리시버만 있을 때: 값·포인터 모두 인터페이스 구현
    var b1 Impl1
    var a1 MyInterface = b1    // OK: Impl1 implements MyInterface
    var a2 MyInterface = &b1   // OK: *Impl1 also has Foo()

    // 2) 포인터 리시버만 있을 때: 포인터만 인터페이스 구현
    var b2 Impl2
    // var a3 MyInterface = b2 // ✗ 컴파일 오류: Impl2에 Foo()가 없음
    var a4 MyInterface = &b2   // OK: *Impl2 implements MyInterface
}
```

### 2. 값타입 리시버와 포인터 타입 리시버
