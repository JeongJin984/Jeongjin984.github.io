---
title: Go에 관하여
description: >-
  go의 코드 구조에 대한 회고록
author: jay
date: 2025-05-18 20:55:00 +0800
categories: [Retrospect]
tags: [gola]
pin: false
media_subpath: ''
---

## golang의 리시버에 관하여

geeson 프로젝의 인증 서버를 go의 gin 라이브러리를 사용해서 구현하다 보니 인터페이스를 구현하고 그를 구현하는 과정에 리시버의 사용에 대해서 혼동이 왔다.

그에 관한 회고 셉션이다.

### 1. 리시버의 구현과 동작 원리

어떤 코드 한줄에 꽂혀서 생각을 하게 되었다. 바로 아래의 코드이다.

자바에서는 위의 코드는 이상하게 느껴진다. repository.UserRepository는 값타입이고 *UserRepositorty는 포인터 타입이다. 그럼 값타입에 포인터를 넣는다고? 이러한 의문이 드는 것이다.
이 의문에는 두가지 오해가 담겨져 있었다.
1. Go의 특징 중 하나는 untyped nil 상수를 모든 포인터 타입(뿐만 아니라 map, slice, chan, func, interface 타입 등)으로 변환할 수 있다는 점
   - var a2 MyInterface = &b1 이런식의 구현도 가능한 것이다.(물론 아래와 같은 제약사항이 있다.)
2. 리시버에서 해당 변수를 사용할때는 구조체 멤버를 대상의 얕은 복사가 이루어지지만 초기화시에는 주소값 대상의 얕은 복사가 이루어진다.(즉 같은 메모리를 가리킨다.)


### 2. 값타입 리시버와 포인터 타입 리시버

값 리시버에 포인터를 넘기는 코드는 Go가 편리하게 자동으로 역참조해 주긴 하지만, 읽는 사람 입장에선 “이게 원본을 바꾸는 건가, 복사본을 바꾸는 건가?” 헷갈릴 수 있을 것 같음

따라서 다음의 원칙을 준수해야함

1. 변경이 필요한 메서드는 포인터 리시버로 통일
2. 불변·작은 데이터엔 값 리시버만 쓰기
   - 단순 조회, 계산용 메서드만 있고 구조체 크기가 작다면
3. 한 타입에 값 리시버와 포인터 리시버를 섞지 않기
4. 인터페이스 구현용 어설션에도 일관성 유지
   - 포인터 리시버 메서드만 있다면 반드시 *T를,
   - 값 리시버만 있으면 T 또는 *T 어느 쪽이든 허용되지만 한 쪽으로 통일
5. 코드 리뷰나 문서에 리시버 전략 명시하기
